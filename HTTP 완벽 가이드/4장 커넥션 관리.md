## 4.1 TCP 커넥션

- HTTP 통신은 TCP/IP를 통해 이루어진다.

`http://naver.com/index.html` 목록을 가져온다고 했을 때

1. 브라우저가 `http://www.naver.com` 이라는 호스트명 호출
2. 해당 호스트명에 대한 IP 주소 찾음
3. 포트번호(기본 80)을 얻음
4. 브라우저가 `IP주소` 의 `포트번호`로 TCP 커넥션 생성
5. 브라우저가 서버로 `GET` 요청을 보냄
6. 브라우저가 서버로부터 온 응답 메시지를 읽음
7. 커넥션 종료

### TCP의 기초적인 내용

1. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
    
    ![http_summary_4_1](https://user-images.githubusercontent.com/55427367/184497101-56ff94a0-2c9b-49b7-af42-1193b76dd8ae.png)

    - HTTP가 메시지를 전송하고자 할 때 연결되어있는 TCP 커넥션을 통해 순서대로 보낸다.
    - TCP는 세그먼트 단위로 데이터 스트림을 나누고, 세그먼트를 IP패킷이라는 봉투에 담아 전달한다.
    
    ![Untitled](https://user-images.githubusercontent.com/55427367/184497113-9af331c8-9547-4012-b9fd-326ba42e6d46.png)

    - IP 패킷 헤더 (20바이트)
    - TCP 세그먼트 헤더 (20바이트)
    - TCP 데이터 조각 (0이상 바이트)
    1. 커넥션 유지하기
    - 컴퓨터는 여러개의 TCP 커넥션을 가지고 있고 포트 번호를 통해 여러개의 커넥션을 관리한다.
    - `<발신지 IP 주소, 발신지 포트, 수신지 IP주소, 수신지 포트>` 로 커넥션을 식별한다.
        - 서로 다른 커넥션들은 4가지 구성요소 값이 모두 같을 수 없다.
    1. TCP 소켓 프로그래밍
        
        pg. 90 참고
        
    

## 4.2 TCP 성능에 대한 고려

- HTTP는 TCP 바로 윗계층이기 때문에 TCP 성능에 영향을 많이 받는다.

### HTTP 트랜 직션 지연 원인?

- 클라이언트는 URI에서 웹 서버의 IP주소와 포트 번호를 알아내야 한다. 방문한 적이 없으면 DNS를 사용하여 호스트명을 IP주소로 변환하는데 시간이 걸린다.
    - 현재는 인프라의 발전으로 대부분 밀리초 이내로 끝남!
- 클라이언트가 서버에게 TCP 요청을 보내고 커넥션 허가 응답을 기다린다.
    - 이 또한 1초 미만으로 끝남
- 요청메시지가 전송되고 처리되는데 소요되는 시간
- 웹 서버가 HTTP 응답을 보내는 시간

### TCP 관련 지연 요소

1. TCP 커넥션 핸드셰이크 지연
    
    TCP 핸드셰이크 순서
    
    1. 클라이언트가 서버에게 `SYN` 플래그를 가진 TCP 패킷을 보낸다.
    2. 서버가 커넥션을 받으면 `SYN`과 `ACK` 플래그를 포함한 TCP 패킷을 보낸다.
    3. 클라이언트가 다시 `ACK` 신호를 보내 응답이 맺어졌음을 알린다.
    - 1번, 2번 과정이 눈에 띄는 지연을 발생시킨다.
    - 크기가 작은 HTTP 요청은 50%이상의 시간을 TCP 커넥션을 구성하는데 사용된다.
2. 확인 응답 지연
    - 패킷 전송을 완벽히 보장할 수 없기 때문에 TCP는 데이터 전송 성공을 위한 자체적인 확인 체계를 갖음
    - 각 TCP 세그먼트는 순번과 무결성 체크섬을 가지는데, 수신자는 세그먼트를 받으면 응답 패킷을 송신자에게 반환해야 한다.
    - 확인응답은 크기가 작기 때문에 데이터 패킷에 편승(piggyback) 시킨다.
    - 확인응답을 데이터패킷에 편승되는 경우를 늘리기 위해 ‘확인응답 지연` 알고리즘을 구현한다.
        - 확인응답을 특정 시간(0.1~0.2초)동안 버퍼에 저장해두고, 편승시키기 위한 데이터 패킷을 찾게 된다.
            
            → 편승할 패킷을 찾기 힘들어 확인응답 지연 알고리즘에 의한 지연이 발생한다.
            
3. TCP 느린 시작
    - TCP 커넥션은 자체적으로 ‘튜닝’되어 데이터가 성공적으로 전송됨에 따라 속도 제한을 높여간다.
    - 1개를 보내고 확인응답을 받으면 2개를 보낼 수 있고.. 그 다음엔 4개 이렇게 증가
    - 이걸 opening the congestion window 라고 함
    - 지속 커넥션을 통해 튜닝된 커넥션을 재사용함
4. 네이글 알고리즘과 TCP_NODELAY
    - 각 TCP 세그먼트는 약 40바이트의 플래그와 헤더를 포함하여 전송하기 때문에, TCP가 작은 크기의 데이터를 포함한 패킷을 전송하게 된다면 네트워크 성능이 떨어지게 된다.
    - 네이글 알고리즘은 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않는다.
        - 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에 지연된다.
        - 확인응답이 도착할 때까지 데이터 전송을 멈추고 있고, 확인응답 지연 알고리즘은 확인응답을 지연시킨다.
    - TCP_NODELAY 플래그로 네이글 알고리즘 비활성화 가능
5. TIME_WAIT의 누적과 포트 고갈
    - 같은 주소와 포트 번호를 사용하는 커넥션이 일정 기간동안 생성되지 않도록 TCP 커넥션을 끊을 때 제어영역에 IP주소와 포트번호를 기록해놓는다.
    - 포트 수가 제한되어있기 때문에 연결이 지연될 수 있다

## 4.3 HTTP 커넥션 관리

### Connection 헤더

- HTTP 헤더 필드 명은, 이 커넥션에만 해당하는 헤더들을 나열한다
    - Connection 헤더에는 홉별 헤더 명을 기술 하는데, 이것이 다음 커넥션에 연결되면 안된다
- 임시적인 토큰 값은 커넥션에 대한 비표준 옵션을 의미한다 ← ??
- close값은 커넥션이 작업이 완료되면 종료됨을 의미한다

## 4.4 병렬 커넥션

그림 pg.102 참고

- 데이터를 병렬로 내려받아 커넥션 지연이 겹쳐짐으로 총 지연시간이 줄게 된다.
- but.. 대역폭이 좁은 경우 장점이 x
- 실제로 병렬 커넥션을 사용하지만, 적은 수(4개)의 병렬 커넥션만 허용
- 사용자의 입장에서는 화면에 작업이 일어나는 것이 보이므로 빠르게 느껴짐

## 4.5 지속 커넥션

- 이미 맺어진 커넥션을 재사용함으로써 커넥션을 맺기 위한 준비 시간을 절약

### 지속 커넥션 vs 병렬 커넥션

- 지속 커넥션은 사전 작업과 지연을 줄여준다
- 튜닝된 커넥션을 유지한다
- 커넥션의 수를 줄여준다
- 계속 연결된 커넥션이 쌓일 수 있다 → 리소스 낭비

### HTTP/1.0+의 Keep-Alive 커넥션

- 클라이언트가 요청에 `Connection: Keep-Alive` 헤더를 포함시킨다.
- 서버는 다음 요청도 해당 커넥션을 통해 받고자 한다면, 같은 헤더를 응답 메시지에 포함한다.
- Keep-Alive 옵션
    - `max`: 몇 개의 트랜잭션을 처리할 때 까지 유지될 것인지
    - `timeout`: 얼마간 유지될 것인지
- Keep-Alive 제한과 규칙
    - 커넥션을 계속 유지하려면 모든 메시지에  `Connection: Keep-Alive` 헤더를 포함해야 한다.
    - 클라이언트는 `Connection: Keep-Alive` 헤더가 없는 응답 메시지를 받으면 연결을 끊을 것임을 알 수 있다.
    - 엔터티 본문 길이(`Content-Length`)값이 정확해야 기존 메시지의 끝과 다음 메시지의 시작점을 정확히 알 수 있다.
    - 프록시와 게이트웨이는 Connection 헤더 규칙을 철저하게 지켜야 한다.
    - 프록시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다. (멍청한 프록시 문제 때문)
- Keep-Alive와 멍청한 프록시
    - 클라이언트의 요청 중 `Connection: Keep-Alive`가 있을 때 프록시는 Connection 헤더를 이해하지 못해 다음 프록시로 전달한다.
    ![Untitled](https://user-images.githubusercontent.com/55427367/184497128-402ef683-b709-4801-854d-486fc6dd2378.png)

    
    - 이러한 문제를 해결하기 위해 `Proxy-Connection` 이라는 헤더를 사용한다. (모든 상황에서 동작하는것은 아님)
    - 영리한 프록시는 의미 없는 `Proxy-Connection`을 Connection 헤더로 바꿔 원하던 효과를 얻을 수 있다. → but.. 멍청한 프록시가 있다면 다시 문제가 발생함

### HTTP/1.1의 지속 커넥션

- 기본적으로 지속 커넥션이고, 커넥션을 끊기 위해 `Connection: close` 헤더를 보내야 한다.
- 지속 커넥션의 제한과 규칙
    - 추가적인 요청이 더 없다면 `Connection: close` 헤더를 보내야 한다.
    - 커넥션에 있는 모든 메시지가 길이 정보를 정확히 알고 있어야 한다.
    - HTTP/1.1 프록시는 서버와 클라이언트 각각에 별도의 지속 커넥션을 맺고 관리한다.
    - HTTP/1.1 프록시 서버는 클라이언트의 지원 범위를 알고있지 않는 한 지속 커넥션을 맺으면 안된다.
    - 중간에 끊어지는 커넥션을 복구할 수 있어야 한다.
    

## 4.6 파이프라인 커넥션

![Untitled](https://user-images.githubusercontent.com/55427367/184497140-6679d1f5-dbf3-41a0-bb7e-3833ee0e31a9.png)

- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서 안된다.
- HTTP 응답은 요청 순서와 같게 와야 한다.
- HTTP 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 있다면 언제든지 다시 요청을 보낼 수 있어야 한다.
- HTTP 클라이언트는 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안된다.
    - ex) `POST` 요청같은 비멱등 요청
    - 에러가 나면 요청 중 어떤 것이 서버에서 처리되었는지 확인할 수 없기 때문
    

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리에는 .. 명확한 기준이 없다 세상에

### 커넥션 끊기의 허용, 재시도, 멱등성

- 에러가 없더라도 언제든 끊을 수 있으므로 HTTP 어플리케이션은 이에 적절히 대응할 수 있어야 한다.
- 멱등성: 한 번 or 여러 번 실행되었는지에 상관 없이 같은 결과가 반환됨
    - `GET` `HEAD` `PUT` `DELETE` `TRACE` `OPTIONS`
- 비멱등인 요청을 다시 보내야 한다면 이전 요청에 대한 응답을 받을 때까지 기다려야 한다.

### 우아하게 커넥션 끊기

- 가장 이상적으로 커넥션을 끊는 방법은 자신의 출력 채널을 끊고 다른 쪽의 출력 채널이 끊기기를 기다리는 것
- 하지만 상대방이 절반 끊기를 구현했다는 것을 보장할 수 없으니 끊고 난 후에도 입력 채널 상태에 대한 검사를 주기적으로 해야 한다.
