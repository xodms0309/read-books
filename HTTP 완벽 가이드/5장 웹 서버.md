## 5.1 다채로운 웹 서버

- 웹 서버는 HTTP 요청을 처리하고 응답을제공한다.

## 5.3 진짜 웹 서버가 하는 일

### 1. 클라이언트 커넥션 수락

- 지속 커넥션을 갖고 있다면 해당 커넥션 사용, 아니라면 새 커넥션을 연다.
- 클라이언트가 웹 서버로 TCP 커넥션을 요청하면, 웹 서버는 TCP 커넥션에서 IP주소를 추출하여 어떤 클라이언트인지 확인한다.
- 대부분의 웹 서버는 역방향 DNS를 사용하여 클라이언트의 IP주소를 호스트명으로 변환함
- 몇 웹서버는 IETF idetn 프로토콜을 사용

### 2. 요청 메시지 수신

- 웹 서버는 네트워크 커넥션에서 데이터를 읽고 파싱한다.
- 요청줄을 파싱하여 요청 메서드, 리소스 식별자(URI), 버전 번호를 찾는다.
- 메시지 헤더를 읽는다.
- 헤더의 끝을 의미하는 CRLF를 찾는다.
- 요청 본문을 읽는다.

웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식이 달라진다.
![05](https://user-images.githubusercontent.com/55427367/184634696-ed2b897d-3246-4ed8-acfb-b0fd08c93f0e.png)


1. 단일 스레드 웹 서버
    - 요청을 한 번에 하나씩 처리
    - 로드가 적은 서버나 진단도구에서만 적당
2. 멀티 스레드 웹 서버
    - 필요할 때마다 스레드를 할당함
    - 너무 많이 만들어지면 메모리/리소스 낭비가 될 수 있음
3. 다중 IO 서버
    - 많은 웹 서버가 다중 아키텍처를 채택
    - 모든 커넥션이 동시에 활동을 감시당함
    - 커넥션의 상태가 바뀌면 그에 대한 처리가 이루어지고 처리가 끝나면 다음을 위해 열린 커넥션 목록으로 돌아감
4. 다중 멀티 스레드 웹 서버

### 3. 요청 처리

- 메서드, 리소스, 헤더, 본문을 얻어 처리하게 된다.

(뒤에서 더 다룰 예정)

### 4. 리소스의 매핑과 접근

- 웹 서버는 리소스 서버다. 미리 만들어진 컨텐츠를 제공하거나 동적 컨텐츠를 제공함
- Docroot: 웹 서버는 요청 메시지의 URI를 가져와 docroot 뒤에 붙여 만들어진 파일을 반환한다.
- 경로가 파일이 아닌 디렉터리를 가리키는 요청을 받을 수 있다.
    - 에러를 반환
    - 특별한 ‘색인 파일’ 반환
    - 디렉터리 탐색 → 그 내용에 대한 html 파일 반환 (그 디렉터리가 index.html 이란 파일을 가지고 있을 때)
- 동적 콘텐츠 리소스 매핑: 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑하는 것
- 접근 제어되는 리소스에 대한 요청이 온다면 클라이언트의 IP 주소에 근거하여 접근하거나 비밀번호를 물어볼 수도 있다.

### 5. 응답 만들기

- 상태코드, 응답헤더, 본문을 포함해서 응답 메시지를 반환하게 된다.
- 응답 엔터티
    - MIME 타입을 정의하는 `Content-Type` 헤더
    - `Content-Length` 헤더
    - 응답 본문
- MIME 타입 결정하기
    - 파일 확장자에 기반하여 결정
    - 매직 타이핑: 표준 확장자가 없는 경우 알려진 패턴에 대한 테이블 탐색
    - 유형 명시: 확장자, 내용에 상관 없이 특정 MIME 타입을 갖도록 설정할 수 있음
    - 유형 협상: 사용자와 협상을 통해 최적의 형식을 설정할 수 있음
- 리다이렉션
    - 리소스가 옮겨진 경우
    - 임시로 리소스가 옮겨진 경우
    - URL 증강: 상태 정보가 내포된 새 URL 생성
    - 부하 균형: 서버가 과부화 됐을 때 덜 부하된 서버로 리다이렉트
    - 해당 클라이언트의 정보를 가진 다른 서버로 이동
    - 디렉터리 이름 정규화 (URI를 요청할 때 `/` 를 빼먹은 경우)

### 6. 응답 보내기

- 비지속적인 커넥션이라면 메시지를 전송 후 커넥션을 끊음
- 지속적인 커넥션이라면 `Content-Length` 를 바르게 계산하기 위해 노력하거나, 응답이 언제 끝나는지 알 수 없는 경우 커넥션을 유지한다.

### 7. 로깅

- 트랜잭션이 어떻게 수행되었는지 로그파일에 기록한다.
